/**
 * Данный модуль содержит интерфейс работы с деревом.
 */
#ifndef __MY_TREE_H__
#define __MY_TREE_H__

#include <stddef.h>
#include <stdbool.h>

#include "my_helps.h"
#include "my_errors.h"

#define MAX_TREE_SIZE 1000
/**
 * Способы обхода: префиксный, инфиксный и постфиксный.
 */
#define DO_BEFORE 0
#define DO_MIDDLE 1
#define DO_AFTER  2

/**
 * Дерево.
 */
typedef struct tree tree;
/**
 * Лист дерева.
 */
typedef struct node_tree node_tree;
/**
 * Указатель на функцию, передаваемую в apply_tree.
 */
typedef void (*ptr_func_tree)(node_tree*, void*);

/**
 * Создание дерева.
 * Возвращает указатель на выделенную память.
 * При возникновении ошибки возвращает нулевой указатель.
 */
tree *init_tree(void);

/**
 * Добавление элемента в дерево.
 * На вход принимает указатель на дерево, а так же имя файла и дату.
 * Возвращает код ошибки.
 * Корректность указателей не проверяется.
 */
int add_to_tree(tree *wood, const char *name, const date *mod);

/**
 * Удаление элемента из дерева по имени.
 * На вход принимает указатель на дерево, а так же имя файла.
 * Возвращает код ошибки.
 * Корректность указателей не проверяется.
 */
int del_by_name_tree(tree *wood, const char *name);

/**
 * Удаление элементов из дерева по дате.
 * На вход принимает указатель на дерево, а так же дату.
 * Возвращает число удалённых элементов.
 * Корректность указателей не проверяется.
 */
int del_earlier_than_tree(tree *wood, const date *deadline);

/**
 * Поиск по дереву.
 * На вход принимает указатель на дерево, а так же имя файла.
 * Возвращает дату.
 * Если файл не будет найден, то вернёт дату (-1, -1, -1).
 * Корректность указателей не проверяется.
 */
date search_tree(const tree *wood, const char *name);

/**
 * Обход дерева.
 * На вход принимает указатель на дерево, указатель на функцию обработки, параметры и способ обхода.
 * Корректность указателей не проверяется.
 */
void apply_tree(const tree *wood, ptr_func_tree func, void *params, const int mode);

/**
 * Вывод состояния дерева.
 * На вход принимает указатель на дерево и ещё один указатель.
 * Корректность указателей не проверяется.
 * Второй указатель не используется, нужен только для упрощения реализации функции, поэтому он никак не повлияет на результат.
 */
void print_leaf_tree(node_tree *node, void *ignored);

/**
 * Получение случайного имени файла без потомков.
 * На вход принимает указатель на дерево и указатель на указатель на строку.
 * Корректность указателей не проверяется.
 */
void get_random_value_tree(node_tree *node, void *ignored);

/**
 * Размер дерева.
 * На вход принимает указатель на дерево.
 * Возвращает количество элементов в дереве.
 * Корректность указателей не проверяется.
 */
size_t size_tree(const tree *wood);

/**
 * Размер памяти для дерева.
 * На вход принимает указатель на дерево.
 * Возвращает размер используемой памяти.
 * Корректность указателей не проверяется.
 */
size_t mem_size_tree(const tree *wood);

/**
 * Проверка на пустоту.
 * На вход принимает указатель на дерево.
 * Возвращает true если дерево пустое, false иначе.
 * Корректность указателей не проверяется.
 */
bool is_empty_tree(const tree *wood);

/**
 * Освобождение памяти.
 * На вход принимает указатель на дерево.
 * Корректность указателя не проверяется.
 */
void destroy_tree(tree *wood);

/**
 * Сохранение дерева.
 * На вход принимает указатель на дерево и имя файла.
 * Возвращает код ошибки.
 * Корректность указателей не проверяется.
 * Существование файла с таким именем не проверяется, если существует, то он перезапишется.
 */
int export_tree(const tree *wood, const char *filename);

#endif // __MY_TREE_H__